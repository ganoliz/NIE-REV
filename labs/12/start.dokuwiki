====== 12. Martin Jirkal (ESET): Analýza dotnet ======

Ing. Martin Jirkal předvede postupy pro analýzu dotnetového kódu.

  * {{:labs:12:cv12.pdf|Prezentace}}
  * {{:labs:12:cv12.zip|Soubory k analýze}}
  * {{:labs:12:dnspy.zip|dnSpy}} - dekompilátor dotnet

====== Injekce ======

Cílem cvičení je injektovat proces ''GUIToSteal.exe'' vlastním kódem tak, aby bylo možné z procesu zkopírovat hodnotu hesla v editačním poli.

{{:labs:12:guitosteal.zip|Soubory ke stažení}}

===== Nápověda =====

K získání textu z můžete například použít funkce:

  * ''GetDlgItemText''.
  * ''GetDlgItem'' a ''GetWindowText''.

Musíme je ovšem zavolat přímo z procesu, který okno spravuje. K tomu využijeme proces nazývaný injekce (Injection).

Pozn.: Všechny tyto funkce pracují s datovým typem ''HWND'', který identifikuje okno (pojem okna není omezen pouze na fyzické okno, ale i například tlačítko, anebo políčko s heslem, jsou okna). Datový typ ''HWND'' je ''HANDLE'' a jde obecně o identifikátor objektu. V některých případech může ''Hxxx'' být "maskovaným" ukazatelem (např. ''HMODULE'' je ukazatel ''PIMAGE_DOS_HEADER'') - obecně ale toto neplatí. 

Postup krádeže hesla je zhruba následující:
  - Nalezneme okno aplikace pomocí funkce ''FindWindow'' a potom funkcí ''GetWindowThreadProcessId'' zjistíme ID procesu, kterému patří.
  - Získáme handle procesu pomocí ''OpenProcess''.
  - Pomocí funkce ''VirtualAllocEx'' můžeme v tomto procesu alokovat paměť, funkcí ''WriteProcessMemory'' můžeme do takto alokované paměti zapsat naše data. Zapíšeme tedy kód, který zavolá některou z funkcí pro přečtení hesla, a nějakým způsobem ho předá útočníkovi (může např. zapsat do dat, která si útočník alokoval a později je přečte pomocí ''ReadProcessMemory'', nebo může pomocí ''WriteProcessMemory'' zapsat přímo do paměti útočníka).
  - Když je vše připraveno, spustíme vytvořený kód pomocí funkce ''CreateRemoteThread''.
  - Konec spuštěného kódu můžeme rozpoznat tak, že počkáme, až vlákno skončí (funkce ''WaitForSingleObject'').

Pozn.: Nebude patrně stačit jen injektovat kód, budete mu také muset předat některá data. ''CreateRemoteThread'' umí předat spouštěnému vláknu jeden parametr, může to tedy být ukazatel na nějakou vaši strukturu.

Pozor! Nevíte, jakou adresu vám ''VirtualAllocEx'' vrátí. Znamená to tedy buď napsat kód, který poběží na libovolné adrese, nebo se o úpravu jeho adres postarat vlastními silami. Asi nejjednodušší i z hlediska ladění je umístit vlastní výkonný kód do samostatného DLL a do procesu injektovat jen kratičký kód, který zavolá ''LoadLibrary'' s potřebnými parametry: vaše knihovna bude načtena do paměti procesu, spustí se její ''DllMain'' funkce, kde můžete provést veškeré útočné činnosti, a potom vlákno ukončíte. Celé vlákno se tak bude skládat jen z několika málo strojových instrukcí, které lze snadno napsat tak, aby fungovaly vždy stejně bez ohledu na umístění v paměti.

Pro ladění injektovaného procesu:
  * Zastavte váš injektor před funkcí ''CreateRemoteThread''.
  * Zjistěte adresu kde se bude pouštět injektovaný thread (''lpStartAddress'').
  * Otevřete OllyDbg a připojte se na injektovaný proces.
  * Nastavte breakpoint na zjištěnou adresu injektovaného kódu a spusťte proces.
  * Spusťte váš injektor.
