
= 4. Import Address Table
:imagesdir: ../media/labs/04
:toc:

* link:https://kib-files.fit.cvut.cz/mi-rev/NI-cviceni_4_paralelka_102.mp4[Záznam cvičení]

== Úvod

Cílem tohoto cvičení je procvičit strukturu PE souboru, zejména tabulky importu symbolů (Import Table) a tabulky adres importovaných symbolů (Import Address Table, IAT). Jednotlivé struktury jsou popsány na https://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v=vs.85).aspx[MSDN], pro lepší pochopení ale může být vhodnější využít některý z tutorialů pro psaní Windows programů v assembleru a/nebo pro crackování, např. https://web.archive.org/web/20190517161709/http://win32assembly.programminghorizon.com/pe-tut1.html[Iczelion's PE Tutorial 1: Overview of PE File Format] a https://web.archive.org/web/20190517161709/http://win32assembly.programminghorizon.com/pe-tut6.html[Iczelion's PE Tutorial 6: Import Table]. Detailní informace o formátu PE souboru si můžete přečíst také ve velmi pěkném http://www.pelib.com/resources/luevel.txt[popisu Bernda Luevelsmeyera].

Grafické znázornění objektů, se kterými budeme na tomto cvičení pracovat:

image::iat.jpg[]

Všechny popisované struktury naleznete v hlavičkovém souboru `windows.h`.

== Nalezení importní tabulky

Pomocí funkce `GetModuleHandle(NULL)` získáme `HMODULE` k aktuálnímu procesu, který přetypujeme na datovou strukturu `PIMAGE_DOS_HEADER`:

[source,cpp]
----
HMODULE hPEFile = GetModuleHandle(NULL); // NULL znamená aktuální proces
PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) hPEFile;
----

Položka `+pDosHeader->e_lfanew+` pak obsahuje relativní virtuální adresu (RVA) NT hlavičky `PIMAGE_NT_HEADERS` vzhledem k začátku PE souboru (tj. od bázové adresy vrácené funkcí `GetModuleHandle`):

[source,cpp]
----
PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS)( ((BYTE*)pDosHeader) + pDosHeader->e_lfanew );
----

Struktura `IMAGE_NT_HEADERS` obsahuje v struktuře `+pNTHeaders->OptionalHeader+` pole s datovými adresáři `DataDirectory`, z nichž každý obsahuje položku `VirtualAddress` (RVA od `pDosHeader`) a položku `Size` s velikostí adresáře v bajtech. Z těchto adresářů jsou pro toto cvičení důležité:

* Importní tabulka -- `+pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]+`
* Import Address Table -- `+pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT]+`

== Importní tabulka

Importní tabulka ukazuje na pole struktur `IMAGE_IMPORT_DESCRIPTOR`.

[source,cpp]
----
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
  union {
    DWORD Characteristics;            // 0 for terminating null import descriptor
    DWORD OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
  } DUMMYUNIONNAME;
  DWORD TimeDateStamp;                // 0 if not bound,
                                      // -1 if bound, and real date\time stamp
                                      //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                      // O.W. date/time stamp of DLL bound to (Old BIND)
  DWORD ForwarderChain;               // -1 if no forwarders
  DWORD Name;
  DWORD FirstThunk;                   // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
----

V ní nás zajímá zejména položka `Name`, které obsahuje RVA na ASCIIZ string (tj. Cčkový `char *`) s názvem DLL, ze které se tímto deskriptorem importují symboly, a dále položka `OriginalFirstThunk` (a pro domácí úlohu i položka `FirstThunk`).

Struktur IMAGE_IMPORT_DESCRIPTOR následuje v paměti za sebou tolik, na kolik DLL knihoven PE soubor linkuje. Ukazatel na první (a na poslední, již neležící v tomto poli) z nich získáme:

[source,cpp]
----
PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(((BYTE*)pDosHeader) + pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
PIMAGE_IMPORT_DESCRIPTOR pImportDescriptorEnd = (PIMAGE_IMPORT_DESCRIPTOR)(((BYTE*)pImportDescriptor) + pNTHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);
----

Konec pole můžeme rozpoznat také podle toho, že poslední validní prvek má v proměnné `Characteristics` hodnotu `NULL`. Otázka do diskuse: Co když jsou tyto dva způsoby určení délky v rozporu? Jaký test by pomohl určit, která z možností má přednost (je skutečně používána operačním systémem)?

Položka `OriginalFirstThunk` obsahuje RVA začátku pole struktur `IMAGE_THUNK_DATA`; velikost pole poznáme tak, že pole končí prázdnou strukturou `IMAGE_THUNK_DATA`. Tato struktura (`PIMAGE_THUNK_DATA`) se automaticky mapuje na jednu z následujících struktur podle toho, jde-li o 32bitový anebo 64bitový PE soubor (v kódu stačí použít pouze `IMAGE_THUNK_DATA`):

[source,cpp]
----
typedef struct _IMAGE_THUNK_DATA64 {
  union {
    ULONGLONG ForwarderString;  // PBYTE
    ULONGLONG Function;         // PDWORD
    ULONGLONG Ordinal;
    ULONGLONG AddressOfData;    // PIMAGE_IMPORT_BY_NAME
  } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#include "poppack.h"                        // Back to 4 byte packing

typedef struct _IMAGE_THUNK_DATA32 {
  union {
    DWORD ForwarderString;      // PBYTE
    DWORD Function;             // PDWORD
    DWORD Ordinal;
    DWORD AddressOfData;        // PIMAGE_IMPORT_BY_NAME
  } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
----

Obsah položky `AddressOfData` pak *obvykle* udává RVA struktury `IMAGE_IMPORT_BY_NAME`, která je definována takto:

[source,cpp]
----
typedef struct _IMAGE_IMPORT_BY_NAME {
  WORD    Hint;
  CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
----

Položka `Hint` obsahuje informaci pro loader, na které pozici se pravděpodobně nachází import v dané knihovně v její Export Address Table (pokud pozice nesouhlasí, hledá se podle jména). Položka `Name` obsahuje ASCIIZ string s názvem importovaného symbolu.

[TIP]
====
Pole `Name` je deklarováno s kapacitou 1 položky typu CHAR. Toto je způsob, jak nadeklarovat strukturu s textem neurčité délky, což Cčko jinak neumí. Nebojte se tedy přistupovat za hranici této struktury. Použijete-li funkci `strcpy_s` s vhodnou velikostí bufferu a budete z tohoto pole číst, bude vše v pořádku.
====

[NOTE]
====
Proč "obvykle"? Na importované symboly lze odkazovat také pořadovým číslem symbolu. V tom případě je `AddressOfData` typu `IMAGE_THUNK_DATA`, přičemž nejvyšší bit položky je nastaven na 1 (tak je tento případ rozpoznáván) a zbylé bity určují pořadí symbolu v knihovně.
====

== Úloha na cvičení

Napište program, který vypíše seznam DLL knihoven, které sám staticky linkuje, a u každého DLL seznam linkovaných symbolů. Nemusíte řešit mezní situace ani UI, cílem této úlohy je seznámit se se strukturou IAT, kterou budeme potřebovat v dalších cvičeních. Váš program ani nemusí dělat nic rozumného vedle výpisu IAT -- zajistěte si ale, např. použitím vhodných API funkcí jako `CreateFileA`, `MessageBoxA` atd., aby určitě bylo co vypisovat, a změnami zde si ověřte, že váš výpis je správně. Kontrolu můžete provést také programem Dependency Walker.

Pokud by vás téma bavilo, zjistěte vztah položky `Hint` k Export Address Table (direktorář č. 0), ovšem jiného modulu -- jeho `HMODULE` a `PIMAGE_DOS_HEADER` můžete získat pomocí volání funkce `GetModuleHandle(TEXT("kernel32.dll"))`.

== Zadání 2. domácí úlohy

* Počet bodů: *5*
* Termín odevzdání:
** *19.11.2020 16:00* (paralelka 101)
** *19.11.2020 17:45* (paralelka 102)
** *19.11.2020 19:30* (paralelka 103)

Váš program, zkompilovaný pomocí MS Visual Studio, typicky používá externí runtime ve formě knihovny `MSVCRT12.DLL` (verze ve jménu se může lišit podle verze kompilátoru, tento název platí pro Visual Studio 2013). Tato knihovna obsahuje funkce `malloc`, `calloc`, `realloc` a `free`. Napište program, který bude obsahovat funkce:

* `MallocDebug_Init`
* `MallocDebug_Done`
* `MallocDebug_malloc`
* `MallocDebug_calloc`
* `MallocDebug_realloc`
* `MallocDebug_free`

Funkce `MallocDebug_Init` najde v IAT pozici funkcí `malloc`, `calloc`, `realloc` a `free` a změní jejich adresu na adresy funkcí `MallocDebug_malloc`, `MallocDebug_calloc`, `MallocDebug_realloc` a `MallocDebug_free` (tzv. substituční funkce).

Substituční funkce napište tak, aby si v okamžiku volání uložily záznam (stačí statické globální pole -- neřešíme konkurenční přístup více vláken ani podporu neomezeného množství alokací, stačí nám pevně dané maximum) o tom, že se alokovala paměť, a o její velikosti. Uvolňující substituční funkce budou tento záznam opět rušit (a stěžovat si, pokud by měly zrušit neznámou nebo uz dříve zrušenou alokaci). Následně substituční funkce zavolají původní funkci, kterou substituují; pozor, nemůžete použít `malloc` -- využijte ukazatele uložené v rámci `MallocDebug_Init`. Získáme tedy schopnost logování paměťových alokačních/dealokačních operací.

Funkce `MallocDebug_Done` vrátí IAT do původního stavu a vypíše případné zbytky tabulky, které budou považovány za memory leaky :). Nezapomeňte vhodně otestovat, že vrácené údaje odpovídají skutečnosti.

[IMPORTANT]
====
Pokud vámi zkompilovaný program nepoužívá externí runtime knihovnu ale knihovnu staticky zakompilovanou přímo do spustitelného souboru, nebude úloha řešitelná. Můžete ale použít parametr `/MD`, kterým přimějete kompilátor k použití sdílené knihovny. Ověřte si v CFF Exploreru, že váš program importuje paměťové funkce!
====

[TIP]
====
*Zápis do IAT*

IAT je obvykle chráněna proti zápisu. Aby do ní bylo možné zapisovat, je nutné nejprve použít např. funkci https://msdn.microsoft.com/en-us/library/windows/desktop/aa366898(v=vs.85).aspx[VirtualProtect] a daný paměťový segment odemknout pro zápis.

[source,cpp]
----
BOOL WINAPI VirtualProtect (
  (LPVOID) lpAddress,   // adresa bloku, jehož stav ochrany chceme měnit
  (size_t) dwSize,      // velikost bloku
  PAGE_READWRITE,       // příznaky ochrany bloku
  (PDWORD)&dwOldProtect // stará hodnota příznaků
);
----
====

[IMPORTANT]
====
Při zpracování importního adresáře nemusíte řešit jiný obsah importního thunku než odkaz na `IMAGE_IMPORT_BY_NAME`, ale jinak musíte zpracovat libovolný, i poškozený importní adresář. Upozornit, že adresář je vadný, a ukončit program je legitimní, spadnout na neplatný přístup do paměti tam, kde jste to mohli zpracováním dle specifikace ošetřit, nikoliv.
====

[NOTE]
====
Je naprosto přípustné, aby program importoval stejnou knihovnu -- a klidně i stejnou funkci z ní -- několikrát.
====

[IMPORTANT]
====
Cílem této úlohy *není*, abyste si napsali vlastní paměťový manager. Naopak by to bylo na škodu -- simulujeme případ, že chceme monitorovat chování programu ve specifické situaci, a je tedy krajně nežádoucí do toho chování vnášet vlastní změny. Vaše implementace by měla zaznamenat údaje, které budete potřebovat, a potom (nebo před tím) zavolat originální verze paměťových funkcí.
====

[IMPORTANT]
====
Vaše implementace by měla odpovídat specifikaci zaměňovaných funkcí. Nastudujte si dokumentaci a ujistěte se, že vaše řešení bude fungovat pro všechny možné mezní stavy, do kterých se paměťové funkce mohou dostat! Velmi častá chyba i u jinak perfektních řešení je, že student nedokázal pokrýt všechna použití paměťových funkcí -- zejména `realloc` má velmi široké možnosti využití!
====

[IMPORTANT]
====
Počítejte s možností, že funkce `MallocDebug_Init` a `MallocDebug_Done` mohou být volány opakovaně a v libovolném pořadí.
====
