
= 13. Injection
:imagesdir: ../../media/labs/13
:toc:

The purpose of this exercise is to understand the process of injection. We will be injecting our own code into the `GUIToSteal.exe` process in order to get the ability to extract the value of the password written into the edit field.

* link:{imagesdir}/cv13.zip[Download]

== Hints

In order to extract the editbox's text, you can use functions such as:

* `GetDlgItemText`, or
* `GetDlgItem` and `GetWindowText`.

They must be called from within the process which owns the window. We will use the injection technique to achieve that.

[NOTE]
====
All of these function use the `HWND` data type, which identifies the window (the term window is not restricted only to physical windows on the screen, but also to buttons, password fields, pop-up menus, the task bar, the Desktop, etc.; all of these objects are windows). The `HWND` data type is opaque, we don't know what lies behind it. Treat it as an object identifier. In some cases, a handle to something `Hxxx` may be a "masked" pointer to the referred object (e.g. `HMODULE` is a `PIMAGE_DOS_HEADER` pointer) -- but that is not a common behavior.
====

=== Stealing the password

. Find the application's window using API `FindWindow`. Use `GetWindowThreadProcessId` to find the ID of the process which owns the window.
. Get the process' handle using `OpenProcess`.
. Allocate memory in this process using `VirtualAllocEx`. We can then use `WriteProcessMemory` to write some data into this memory. Use the function to write a piece of code which will grab the password and pass it on to the caller (e.g. by writing it into a memory within the injected process, where it can later be read using `ReadProcessMemory`, writing it directly into the password stealer's memory using `WriteProcessMemory`, saving the password into a file or using a named pipe to send the password to the stealer).
. When the code is ready, run it using `CreateRemoteThread`.
. You will get the thread's handle. Wait until the thread completes by passing the handle to the `WaitForSingleObject` API.

[TIP]
====
Obviously, you can't inject just the code -- you also need to pass it some data. `CreateRemoteThread` can pass one argument to the new thread -- it could be a pointer to some structure of yours.
====

[IMPORTANT]
====
Beware! You don't know which address you will get from `VirtualAllocEx`. That means that your code must either be location-independent, or you need to perform relocation manually. Probably the simplest solution to this problem, also considering the debugging needs you will probably have, is to write the actual code as a part of a standalone DLL, and inject only a tiny piece of code which will call `LoadLibrary` with the name of your library: The library will be loaded into memory and relocated by the operating system. Its `DllMain` function will be called. You can perform all the necessary attack functionality there, then you can terminate the thread. Overall, that means the thread will only contain a handful of instructions which are easy to write in a position-independent way.
====

=== Debugging the injected process:

. Stop the injector before the `CreateRemoteThread` call.
. Find the injected thread's entry point address. This is typically contained in the `lpStartAddress` parameter.
. Open OllyDbg and attach it to the process into which the thread is going to be injected.
. Set a breakpoint at the address found in step 2 and let the process continue.
. Run the injector.
