====== 4. Import Address Table ======

===== Introduction =====

The aim of this exercise is to practice the PE file structure, particularly the symbol import tables (Import Table) and the table of addresses of imported symbols (Import Address Table, IAT). The structures are described in [[https://msdn.microsoft.com/en-us/library/windows/desktop/ms680313(v=vs.85).aspx|MSDN]]. For a better understanding of them, it might be better to use one of the tutorials for writing Windows programs in assembler and/or cracking, for example [[http://win32assembly.programminghorizon.com/pe-tut1.html|Iczelion's PE Tutorial 1: Overview of PE File Format]] and [[ http://win32assembly.programminghorizon.com/pe-tut6.html|Iczelion's PE Tutorial 6: Import Table]].

A graphical representation of objects with which we will be working throughout this exercise:

{{:labs:04:iat.jpg|}}

===== Finding the Import Address Table (IAT) =====

The ''GetModuleHandle(nullptr)'' gets us an ''HMODULE'' of the current process, which we can cast into the ''PIMAGE_DOS_HEADER'' structure.

<code c>
  HMODULE hPEFile = GetModuleHandle(nullptr); // nullptr means the current process
  PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) hPEFile;
</code>

The ''pDosHeader-''''>e_lfanew'' field contains the relative virtual address (RVA) of the NT header ''PIMAGE_NT_HEADERS'' structure relative to the beginning of the PE file (i.e. the base address returned by ''GetModuleHandle''):

<code c>
  PIMAGE_NT_HEADERS pNTHeaders = (PIMAGE_NT_HEADERS) (((BYTE *)pDosHeader) +  pDosHeader->e_lfanew);
</code>

The ''IMAGE_NT_HEADERS'' structure includes a field ''pNTHeaders-%%%%>OptionalHeader''. This field contains an array of data directories ''DataDirectory''; each directory contains a field called ''VirtualAddress'' --- an RVA from ''pDosHeader'' and a field ''size'' carrying its size in bytes. Two of these directories are critical for this tutorial:

  * Import Table - ''pNTHeaders -%%%%> OptionalHeader.DataDirectory[1]''
  * Import Address Table - ''pNTHeaders -%%%%> OptionalHeader.DataDirectory[13]''

===== The Import Table =====

The Import Table points to an array of ''IMAGE_IMPORT_DESCRIPTOR'' structures.

<code c>
  typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
      DWORD Characteristics;    // 0 for terminating null import descriptor
      DWORD OriginalFirstThunk; // RVA's original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD TimeDateStamp;  // 0 if not bound,
                          // -1 If bound, and real date \ time stamp
                          // In IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                          // O.W. date / time stamp of the DLL's bound (Old BIND)
    DWORD ForwarderChain; // -1 If no forwarders
    DWORD Name;
    DWORD FirstThunk;     // RVA's IAT (if this bound IAT has actual addresses)
  } IMAGE_IMPORT_DESCRIPTOR;
</code>

In the above structure, we are particularly interested in field ''Name'', which contains an RVA to an ASCII string (i.e. the C ''char *'') with name of the DLL from which this descriptor imports symbols, and then the ''OriginalFirstThunk'' field (and for the homework the ''FirstThunk'' field).

There are as many ''IMAGE_IMPORT_DESCRIPTOR'' structures in memory as there are DLLs this PE file links to. A pointer to the first (and the last -- lying after the structures) can be obtained:

<code c>
  PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) (((BYTE *) pDosHeader) + pNTHeaders-> OptionalHeader.DataDirectory [IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
  PIMAGE_IMPORT_DESCRIPTOR pImportDescriptorEnd = (PIMAGE_IMPORT_DESCRIPTOR) (((BYTE *) pImportDescriptor) + pNTHeaders-> OptionalHeader.DataDirectory [IMAGE_DIRECTORY_ENTRY_IMPORT].Size);
</code>

The end of the array can also be recognized by the fact that the last valid element has the value of the ''Characteristics'' field set to ''nullptr''. A question: What if these two ways of determining the length are in conflict? Which test would let us determine which option takes priority (i.e., what the operating system does)?

The ''OriginalFirstThunk'' field contains an RVA beginning of the array of structures ''IMAGE_THUNK_DATA''; the array ends with an empty ''IMAGE_THUNK_DATA'' structure. This structure (''PIMAGE_THUNK_DATA'') is automatically mapped to one of the following structures, depending on whether this is a 32-bit or a 64-bit PE file:

<code c>
  typedef struct {_IMAGE_THUNK_DATA64
    union {
      ULONGLONG ForwarderString; // PBYTE
      ULONGLONG Function; // PDWORD
      ULONGLONG Ordinal;
      ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
  } IMAGE_THUNK_DATA64;
  typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

  #include "poppack.h" // Back to 4 byte packing
  
  typedef struct {_IMAGE_THUNK_DATA32
    union {
      DWORD ForwarderString; // PBYTE
      DWORD Function; // PDWORD
      DWORD Ordinal;
      DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME
    } u1;
  } IMAGE_THUNK_DATA32;
  typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
</code>

The field ''AddressOfData'' **usually** indicates the RVA of the ''IMAGE_IMPORT_BY_NAME'' structure, which is defined as follows:

<code c>
  typedef struct {_IMAGE_IMPORT_BY_NAME
    WORD Hint;
    CHAR Name [1];
  } IMAGE_IMPORT_BY_NAME * PIMAGE_IMPORT_BY_NAME;
</code>

The ''Hint'' field contains information for the loader, the position where the symbol is likely to be found in the library in the Export Address Table (if the position does not match, the symbol is looked up by its name). The ''Name'' field contains an ASCIIZ string with the name of the imported symbol.

<note>The ''Name'' field is declared with a size of 1 CHAR. This is a way of declaring that there will be a string of indeterminate length. Do not be afraid to access beyond the bounds of this structure. If you use ''strcpy_s'' with an appropriately sized buffer and you read from this field, everything will be fine.</note>

<note> Why "usually"? Imported symbols may also be referred by their ordinal number. In this case, the ''AddressOfData'' is of type ''IMAGE_THUNK_DATA'' and the highest bit of the item is set to 1 (which is how we can recognize this situation), and the remaining bits determine the order of the symbol in the library.</note>

===== Exercise for the Lab ===== 

Write a program that prints a list of DLLs it is linked against, and for each DLL a list of imported symbols. You do not need to deal with extreme conditions or UI, the purpose of this task is to get acquainted with the structure of IAT. We will need it in the following exercises. Your program does not have to do anything besides printing out a list of DLLs and symbols, but it would be wise to explicitly use API calls such as ''CreateFileA'' or ''MessageBoxA'' to ensure that some symbols are actually being imported. You can also check your result with the output of the Dependency Walker tool.

If you liked this assignment, find a relationship of the ''Hint'' field and the Export Address Table (Directory no. 0) of another module such as (''kernel32.dll''). You can get its ''HMODULE'' and ''PIMAGE_DOS_HEADER'' by calling e.g. ''GetModuleHandle(TEXT ("kernel32.dll"))''.

===== Third Exercise =====

  * Points: **5**
  * Deadline: **2017-11-21, 17:45**
  
/*
<note>This is not a mistake and you haven't overlooked anything. The designation "third" refers to the points in the evaluation. The second task, which gives you 10 points, will be awarded for up to the next exercise.</note>
*/

Your program uses an external runtime library ''MSVCRT12.DLL'' (the version in the name may vary according to the compiler version, this name applies to Visual Studio 2013). This library contains functions ''malloc'', ''calloc'', ''realloc'', and ''free''. Write a program which will contains functions:

  * ''MallocDebug_Init''
  * ''MallocDebug_Done''
  * ''MallocDebug_malloc''
  * ''MallocDebug_calloc''
  * ''MallocDebug_realloc''
  * ''MallocDebug_free''

The ''MallocDebug_Init'' will find the IAT position of the ''malloc'', ''calloc'', ''realloc'', and ''free'' functions and change (= patch) their addresses in the IAT to the addresses of ''MallocDebug_malloc'', ''MallocDebug_calloc'', ''MallocDebug_realloc'', and ''MallocDebug_free'' respectively. The patched functions will keep track of all allocations via ''malloc'', ''calloc'', ''realloc'', and ''free'' and will complain if you try to free an already-freed block. The ''MallocDebug_Done'' function will report any non-freed memory blocks and then will return the IAT to its original state. It is not required that your functions be thread-safe. In the real world, you have to make them thread-safe, that is assume that each of the function could be called at any time concurrently and you'd have to synchronize access to your data structures.

<note>**Writing into the IAT**

IAT is write-protected. In order to be able to write into it, you must use e.g. the [[https://msdn.microsoft.com/en-us/library/windows/desktop/aa366898(v=vs.85).aspx|VirtualProtect]] API and unlock the page for writing.

<code c>
  BOOL WINAPI VirtualProtect (
    (LPVOID) lpAddress,   // an address in a block to change memory protection for
    (size_t) dwSize,      // size of the block
    PAGE_READWRITE,       // memory protection flags
    (PDWORD)&dwOldProtect // old protection value
  );
</code>
</note>


<note>
It is **not** the purpose of this task to write a new memory manager. Quite the opposite, in fact - we are modelling an attempt to monitor a program's behavior in a specific area, and it rather defeats the purpose if we drastically change the area. Your implementation should simply store the necessary logging data and then (or before that) call the original versions of the memory management functions.
</note>

