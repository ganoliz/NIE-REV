====== 2. Program debugging, analysis of functions and stack frames ======

We will be using IDA Free to debug our programs. You can download it here" [[https://www.hex-rays.com/products/ida/support/download_freeware.shtml]].

We have compiled the following sample. The compilation took place in Visual Studio.NET 2015 Community Edition, in Release mode, with ASLR (''/DYNAMICBASE:OFF'') disabled, optimization disabled (''/Ob0'') and with a Multibyte character set. {{:labs:02:cv2_1.zip|}}.

Note that the program contains a software breakpoint instruction (''int3'', opcode ''CC'') for your convenience. Under normal circumstances this instruction causes the program to crash, unless a debugger is present on your computer. If a debugger is present, it pops up, stopping the program at this instruction. Load this program into IDA Free and run it by pressing the F9 key. The program can stop on other than only this instruction (actually the ''int3'' instruction causes an exception which is passed to the debugger). If the program stops at address beginning with ''7xxxxxxx'' (an address in within a system library), continue with F9 until it stops in program code at address ''401357''.

Breakpoint in the library:

{{:labs:02:cv2obr01.png|}}

Breakpoint in the program:

{{:labs:02:cv2obr02a.png|}}

==== Prologue, Epilogue ====

First we examine the prologue of a common function. Switch IDA to IDA View-A (if you see a diagram with code blocks, press spacebar to switch to a list of code). Type ''g'' and enter ''401259'' to get to that address *or* scroll in the window until you see it. Notice a function call at address ''401040'':

{{:labs:02:cv2obr03.jpg|}}

The function is called with 2 arguments. Under the function call we can see that the arguments are cleaned-up from the stack by the ''add esp, imm'' (''imm'' means the immediate value, and it is a number in this case). From the clean-up add instruction we can deduct that the function is using the ''%%__%%cdecl'' calling convention.

{{:labs:02:cv2obr04.jpg|}}

''call'' is an instruction which does 2 operations: (i) Pushes the address of the instruction following the call on the stack, and (ii) sets the ''EIP'' register to a value specified as its operand (this is typically an address in the program, library or register).

{{:labs:02:cv2obr05.jpg|}}

{{:labs:02:cv2obr06.jpg|}}

In prologue of the function the previous base pointer value (the ''EBP'' register) is pushed on the stack and a new stack frame is established by copying the current ''ESP'' register value into ''EBP''.

{{:labs:02:cv2obr07.jpg|}}

Next, space is allocated for local variables by using the ''sub'' instruction. We must use the ''sub esp, imm'' instruction to allocate space, as stack grows toward zero. The lesser value (''ESP'') has , the more data is there. In our case space for 2 ''DWORD''s is allocated.

{{:labs:02:cv2obr08.jpg|}}

This is the basic prologue, a standard function introduction. Epilogue serves as a standard function termination and reverses what prologue did.

{{:labs:02:cv2obr09.jpg|}}

First, ''ESP'' is restored to its previous value, which also removes the local variables. The ''mov esp, ebp'' instruction reverses the ''sub esp, imm'' instruction in prologue. Then a ''pop ebp'' instruction is used to restore ''EBP''. Ultimately a ''RETN'' instruction is issued, which returns to the place stored by the ''call'' instruction and removes it from the stack (''pop eip'').

==== Structured Exception Handling (SEH) ====

Let's return to address ''401320''.

{{:labs:02:cv2obr10.jpg|}}

A standard prologue begins.

{{:labs:02:cv2obr11.jpg|}}

Then an ''_EXCEPTION_REGISTRATION'' structure is pushed on the stack:

  struct _EXCEPTION_REGISTRATION {
    struct _EXCEPTION_REGISTRATION *prev;
    void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
    struct scopetable_entry *scopetable;
    int trylevel;
  };

{{:labs:02:cv2obr12.jpg|}}

The address of this structures is placed into ''FS:[0]'' and this one is linked via the ''prev'' field to the former one. When an exception occurs, the ''FS:[0]'' value is examined.

Finally, the stack looks like this:

{{:labs:02:cv2obr13.jpg|}}

The Epilogue is simpler:

{{:labs:02:cv2obr14.jpg|}}

Prologue and Epilogue code is mostly irrelevant to analysis except for blocks used in ''%%__%%except''/''%%__%%finally'' in C or ''catch'' in C++.

Note that exception implementation may be dependent on the compiler used to compile the software. For this reason exceptions thrown from libraries are often incompatible with the ones used in the program, unless the same compiler is used. Once an exception occurs an ''EXCEPTION_REGISTRATION'' pointer is taken from ''FS:[0]'' and now it depends whether the control is passed directly to the program or to library -- the address of the filter routine is in the ''lpfnFilter'' field of the ''EXCEPTION_REGISTRATION'' structure. In case of SEH3 (version 3) or SEH4, we have to examine the ''scopetable'' field, which is of type ''SCOPETABLE''.

<code c>
  typedef struct _SCOPETABLE {
    DWORD previousTryLevel;
    DWORD lpfnFilter
    DWORD lpfnHandler
  } SCOPETABLE, *PSCOPETABLE;
</code>

{{:labs:02:cv2obr15.jpg|}}

In our case we see that the first two ''trylevel'' variables are empty and ''trylevel==0xFFFFFFFE'' (-2) means it is a C exception block (-1 means a C++ exception block). There is a an exception filter (''lpfnFilter'') at address ''401427'' and the **except** function at ''40142D''.

The filter looks like this:

{{:labs:02:cv2obr16.jpg|}}

The number ''C0000094'' is an enumerated constant ''EXCEPTION_INT_DIVIDE_BY_ZERO''.

The function ''except(EXCEPTION_INT_DIVIDE_BY_ZERO)'' looks like this:

{{:labs:02:cv2obr17.jpg|}}

The function restores the stack, sets the ''trylevel'' and sets result into ''EAX'' to 1.

==== Variables ====

If we look at address ''401364'', we can note a section where local variables are assigned. Using the ''h'' key, you can change the representation from decimal into hexadecimal and vice versa. Using the ''k'' key you can switch in between IDA representation and the offset representation --- ''[ebp+arg_4]'' changes into ''[ebp+0ch]'', etc.

{{:labs:02:cv2obr18.jpg|}}

There are two ''DWORD'' variables and two ''BYTE'' variables. We can rename them from ''var_8'' for example to ''DWORD1'' by using the ''n'' key.

{{:labs:02:cv2obr19.jpg|}}

Since ''4013E7'' we can notice that these variables are used and their values are copied into registers.

{{:labs:02:cv2obr20.jpg|}}

{{:labs:02:cv2obr21.jpg|}}

The address ''EBP-38'' is then used as an argument of the function at ''401240''.

If we look into this function (hit the ''Enter'' key on its address or double click), we can find that that the address in argument (i.e. ''EBP-38'' in the previous stack frame) is used as ''[REG]'', ''[REG+4]'', ''[REG+5]'' etc. We can deduct that that the argument of the fuction ''401240'' is a pointer to a structure, which is a local variable in the previous stack frame. Size of the structure is important only for the compiler and the compiled code does not contain this information, unless it is used e.g. for memory allocation by means of the ''sizeof(structure)''. Its size can be only guessed from the content of the ''401240'' function.

{{:labs:02:cv2obr22.jpg|}}

{{:labs:02:cv2obr23.jpg|}}

The code takes a value of the ''DWORD1'' variable and uses the compare (''cmp'') instruction. This instruction tells us that ''DWORD1'' is a 4-byte integer -- perhaps ''int'' or ''unsigned int'' in C -- we cannot tell for sure which one yet. The conditional jump instruction (''jge'') is used to compare **signed** values so now we can be sure that ''DWORD1'' is an ''int''. We can use similar approach to discover size and signedness of the other 3 variables.

{{:labs:02:cv2obr24.jpg|}}

The next variable is a ''char''. We can also see that there's a ''jge'' instruction. Moreover the ''movsx'' instruction (sign extend) is used to extend a signed data type into 32 bits, while the ''movzx'' instruction (zero extend) would be used for an ''unsigned char''.

{{:labs:02:cv2obr25.jpg|}}

The next variable is also a ''char'', but ''movzx'' tells us that this one is an ''unsigned char''.

{{:labs:02:cv2obr26.jpg|}}

The fourth variable is also an integer but the jump instruction ''jnb'' is typical for ''unsigned int''s.

==== API ====

Let's look at function ''401140'' and note that this function takes as argument the structure we have just analyzed. We can see that there're several calls to the Windows API, namely to ''CreateFileA'' and ''WriteFile''. Let's start with the ''CreateFileA'' function first. You can lookup its documentation in MSDN here [[https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858%28v=vs.85%29.aspx]].

{{:labs:02:cv2obr27.jpg|}}

Now we see the meaning of all parameters that are passed to the ''CreateFileA'' function and find out that this function creates a file. The ''CreateFile'' name is a little bit misleading, since the function is commonly used to open a file for reading.

IDA is clever enough to annotate code for us and we can further help it by choosing constants (enums) from the list. Click at 40000000h in the dwDesiredAccess line and hit the ''m'' key. You should be able to select ''GENERIC_WRITE'' from the list. You can do the same for file attributes (''FILE_ATTRIBUTES_NORMAL'') and for create mode (''CREATE_ALWAYS'').

{{:labs:02:cv2obr28.jpg|}}

The result of the ''CreateFileA'' function is a ''HANDLE''. This ''HANDLE'' is stored in a variable named ''hFile''.

Examine the following piece of code:

{{:labs:02:cv2obr29.jpg|}}

If we look at the used string, we can think out that it looks like a ''printf'' formatting string. If we examine more thoroughly the function at ''401100'' and functions this function calls, we can observe a call to ''%%__%%stdio_common_vsprintf'' at ''4010A9''. The documentation tells us what are the expected types of variables (the conversion specifiers in the printf string such as %d is an ''int'', %u ''unsigned int'', etc.) and we can use this information to rectify signedness and type information for our local variables. The string gives us also an idea how should we rename (via the ''n'' key) our local variables. Ultimately we obtain:

<code>
  DWORD1 -> int width
  BYTE1 -> char height
  BYTE2 -> unsigned char Xsize
  DWORD2 -> unsigned int Ysize
</code>

Now we can create the structure:

<code c>
struct MyStructure {
  int width;
  char height;
  unsigned char Xsize;
  unsigned int Ysize;
};
</code>

==== Caution ====

If you look at source code carefully, we can discover that our analyses went wrong in few cases.

  - The structure has 4 additional parameters. These 4 integers were unreferenced in the program so we do not know about them at all. We can, however, note that the ''sub esp, imm'' calculates with proper length. Since this is a unoptimized build of the program, this (unnecessary) information still remains visible.
  - Compilation discards a lot of information (comments, structure boundaries, etc.). This makes any analysis imprecise. Despite this we can obtain a similar (rarely the same) source code as the original source code.

