====== 6. Run Type Information Identification Analysis ======

===== Motivation =====
If a program uses identification of types at runtime (Run Time Type Identification, RTTI), such as when it is using the ''typeid'' or ''dynamic_cast'' operator, the program needs to contain information about class relationships and other information which can be used in well during its reverse engineering. The purpose of this exercise is to demonstrate how virtual methods are called, how this relates to the virtual method tables, where and how are these tables stored, and how this corresponds to type information in RTTI. We will extract a class name and inheritance information from RTTI metadata.

===== Virtual Method Table =====
The virtual method table (Virtual Method Table, VMT) is present in all objects that have virtual methods. Each row of this table contains a pointer to the method or a pointer to the ''_purecall'' function (MSVC) if the method is not implemented and the class is abstract. In simple objects a VMT pointer is saved as the first item in the class/struct. The VMT address can be obtained as:

<code c>
pVMT = *(void**)this
</code>

**Note:** In order for an object to have a VMT, it must be polymorphic (i.e. have virtual methods), otherwise the first item in the class contains the first data. 

VMT is assigned in the constructor (ctor). If there's no constructor, a compiler provides an implicit constructor. The VMT is usually assigned as one of the last things ctors do: 
<code asm>
(gdb) x/20i 'IUnknown::IUnknown()'
   0x400ac6 <IUnknown::IUnknown()>:     push   %rbp
   0x400ac7 <IUnknown::IUnknown()+1>:   mov    %rsp,%rbp
   0x400aca <IUnknown::IUnknown()+4>:   mov    %rdi,-0x8(%rbp)
   0x400ace <IUnknown::IUnknown()+8>:   mov    -0x8(%rbp),%rax
   0x400ad2 <IUnknown::IUnknown()+12>:  movq   $0x400fd0,(%rax) ; VMT assignment
   0x400ad9 <IUnknown::IUnknown()+19>:  pop    %rbp
   0x400ada <IUnknown::IUnknown()+20>:  retq
</code>

If we list the VMT:

<code asm>
(gdb) x/4a 0x400fd0
0x400fd0 <_ZTV8IUnknown+16>:	
  0x4007d0 <__cxa_pure_virtual@plt>
  0x4007d0 <__cxa_pure_virtual@plt>
  0x4007d0 <__cxa_pure_virtual@plt>
  0x0
</code>

we obtain an information that the above class is an abstract class. Yes, if we look at the declaration of the ''IUnknown'' class in ''<unknwn.h>'' header file in the Windows SDK, we find that all methods in the class have =0 at the end and that means the method is pure virtual and thus the class is abstract. If we list VMT for another class deriving from ''IUnknown'' such as our class ''CUnknown'',

<code asm>
(gdb) x/4a 0x400f70
0x400f70 <_ZTV8CUnknown+16>:	
  0x4007d0 <__cxa_pure_virtual@plt>	
  0x4008f6 <CUnknown::AddRef()>
  0x400914 <CUnknown::Release()>	
  0x0
</code>

we discover that the ''CUnknown'' class is also abstract, since it only overrides the ''AddRef'' and ''Release'' methods, but leaves the ''QueryInterface'' method unimplemented. What we have discovered? We have found that functions on addresses 4008f6 and 400914 belong to the same class. With VMT, we can identify the class. The VMT pointer is shared by all instances of the class. We do not know the class name (well a debug information present in the above program tells us the class is named CUnknown, but we can find this out from RTTI, even with no debugging information).

===== Type Information =====
RTTI keeps information about types and their inheritance. Without RTTI it was not possible to implement the ''dynamic_cast'' operator and cast from base class to derived classes. The type information is stored as the -1st (yes, -1) entry in the VMT:

<code c>
pVMT = *(void**)this
void* pTypeInfo = ((void**)pVMT)[-1]
</code>

The content of the type information depends on the compiler and its runtime. Lecture slides show this for the Microsoft C++ compiler where the basic type information ''pTypeInfo'' points at the ''RTTICompleteObjectLocator'' structure:

<code cpp>
typedef struct _RTTICompleteObjectLocator
{
  DWORD signature;
  LONG offset;
  LONG cdOffset;
  _RTTITypeDescriptor * pTypeDescriptor;
  _RTTIClassHierarchyDescriptor * pClassHierarchyDescriptor;
}
_RTTICompleteObjectLocator;
</code>

Other structures are used from the above structure. The ''_RTTITypeDescriptor'' contains the class/struct name, while ''_RTTIClassHierarchyDescriptor'' contains information about inheritance of the class/struct.

<code c>
typedef struct _RTTITypeDescriptor
{
  void* __vftbl;
  void* data;
  char d_name[1]; // Mangled data type name
}
_RTTITypeDescriptor, TypeDescriptor;
</code>

Další struktury ukazují na hierarchii tříd:

<code c>
typedef struct PMD
{
  ptrdiff_t mdisp; //vftable offset
  ptrdiff_t pdisp; //vftable offset
  ptrdiff_t vdisp; //vftable offset(for virtual base class)
};

typedef const struct _s_RTTIBaseClassDescriptor
{
  TypeDescriptor *pTypeDescriptor;
  DWORD numContainedBases;
  PMD where;
  DWORD attributes;
} _RTTIBaseClassDescriptor;

typedef const struct _s_RTTIBaseClassArray
{
  _RTTIBaseClassDescriptor *pArrayOfBaseClassDescriptors[1]; // A variable sized array
}
_RTTIBaseClassArray;

typedef const struct _s_RTTIClassHierarchyDescriptor
{
  DWORD signature;
  DWORD attributes;
  DWORD numBaseClasses;
  _RTTIBaseClassArray *pBaseClassArray;
}
_RTTIClassHierarchyDescriptor;
</code>

===== Fourth Exercise =====

^ Points ^ Submission Date ^ Time  ^
|   5    | 12.01.2017      | 24:00 |

Analyze the ''Had.exe'' executable from here {{:en:labs:06:had2016.zip|had2016.zip}}. 
  - Examine the program and find all object ctors and VMT assignments.
  - From VMTs discover which class has which amount of virtual methods.
  - Find those class names and their inheritance from the RTTI information.
  - **Bonus:** Patch the program so you have an unlimited number of lifes.

===== Bibliography =====

  - Igorsk: Reversing Microsoft Visual C++ Part II: Classes, Methods and RTTI. Available online at [[http://www.openrce.org/articles/full_view/23|http://www.openrce.org/articles/full_view/23]], 2006.
  - Microsoft Corp.: rttidata.h: Available online at [[http://read.pudn.com/downloads10/sourcecode/os/41823/WINCEOS/COREOS/CORE/CORELIBC/CRTW32/RTTI/rttidata.h__.htm
|http://read.pudn.com/downloads10/sourcecode/os/41823/WINCEOS/COREOS/CORE/CORELIBC/CRTW32/RTTI/rttidata.h__.htm
]].
  - Passion wu128: rtti.h: Available online at [[http://m.blog.csdn.net/blog/passion_wu128/38511957|http://m.blog.csdn.net/blog/passion_wu128/38511957]], 2014.

===== Files =====
{{:en:labs:06:cv6.zip|Initial file}}
{{:en:labs:06:cv6_classexample.rar|IDA Free IDB file}}